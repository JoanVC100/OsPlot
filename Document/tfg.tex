\documentclass{tfgitic}[2023/06/30]
% per a fórmules químiques
\usepackage[version=4]{mhchem}
% Per dibuixar gràfics: base general i gràfics senzills
\usepackage{tikz} \usetikzlibrary{arrows}
% Per dibuixar gràfics: circuits electrònics
\usepackage[europeanresistors,americaninductors]{circuitikz}
% Per dibuixar gràfics: diagrames diversos
\usepackage{pgfplots}
% Per escriure algoritmes
\usepackage[plain,figure]{algorithm2e}
% Per a usar taules elàstiques
\usepackage{tabularx}

% Indica quines bd bibliografiques usarem
\addbibresource{tfg.bib}

% Marges en els algoritmes
\setlength{\algomargin}{4em}

% Versió de pgfplots a usar
\pgfplotsset{compat=newest}

\definecolor{tufte1}{rgb}{0.7,0.7,0.55}
\definecolor{yellowmarker}{HTML}{DEF440}

\pgfplotsset{
	tufte bar/.style={
		ybar,
		axis line style={draw opacity=0},
		xtick=\empty,
		ymin=0,
		bar width=3mm,
		x=2*\pgfkeysvalueof{/pgf/bar width},
		ymajorgrids,
		grid style=white,
		axis on top,
		major tick length=0pt,
		cycle list={
			fill=tufte1, draw=none\\
		},
		enlarge x limits={
			abs=0.5*\pgfkeysvalueof{/pgf/bar width}
		},
		axis x line*=bottom,
		x axis line style={
			draw opacity=1,
			tufte1,
			thick
		},
		yticklabel=\pgfmathprintnumber{\tick}\,\%
	}
}

\title{OsPlot: Com implementar osci\lgem oscopis amb un microcontrolador i Linux}

\subtitle{Subtítol}

\author{Joan Vilardaga Castro}

\advisor{Francisco Del Aguila López}

\dedication{Dedicació}

\begin{acknowledgments}
Tot el meu agraïment.
\end{acknowledgments}

\begin{resum}
Aquest document descriu una solució anomenada OsPlot, una arquitectura
genèrica que permet transformar un microcontrolador i un ordinador en
un osci\lgem oscopi funcional. Mitjançant l'ús de plataformes obertes
com Linux, Arduino i GNUPlot, aquesta investigació intenta oferir una
solució de baix cost i accessible per a gent interessada en l'anàlisi
de senyals.
\end{resum}

\begin{abstract}
This document describes a solution named OsPlot, which is a generic
architecture that allows transforming a microcontroller and a computer
into a functional oscilloscope. By using open platforms such as Linux,
Arduino and GNUPlot, this research aims to provide a low-cost and
accessible solution for people interested in signal analysis.
\end{abstract}

\begin{document}

\part{Memòria}

\chapter{Introducció}
\label{cap:intro}

\section{Origen del treball: Osci\lgem oscopi amb GNUPlot}
\label{sec:origen}

GNUPlot \cite{gnuplot} és un programa de traçat de gràfics en 2D i 3D
que permet visualitzar i analitzar diferents conjunts de dades. Tot i
que GNUPlot és una eina per fer gràfics estàtics, es pot combinar amb
altres programes o ``scripts'' per aconseguir la funcionalitat de
traçat en temps real.

És precisament aquest descobriment el que ha obert la porta a la
possibilitat de fer un osci\lgem oscopi amb GNUPlot com a plataforma
principal. Així, aquesta investigació s'enfoca a explorar la
viabilitat d'utilitzar GNUPlot per a la creació d'un osci\lgem oscopi
digital totalment funcional.

\section{Objectius}
\label{sec:objectius}

\begin{enumerate}
	\item Evaluar la capacitat de GNUPlot per visualtizar dades en
          temps real.
	\item Desenvolupar i avaluar OsPlot com a solució genèrica per
          transformar un microcontrolador i un ordinador en un
          osci\lgem oscopi.
	\item Implementar programes de referència que explotin les
          diferents possibilitats de l'arquitectura.
\end{enumerate}

\section{Com funciona un osci\lgem oscopi}
\label{sec:com-funciona-oscil·loscopi}

Un osci\lgem oscopi \cite{viqui-oscil·loscopi} és un instrument de
mesura que s'utilitza per visualitzar i analitzar senyals elèctrics
variables en el temps. Com amb moltes altres coses, els osci\lgem
oscopis són instruments que han evolucionat amb la digitalització,
creant una nova generació d'osci\lgem oscopis més precisos i que poden
fer operacions molt més complexes com mitges, pic a pic o
transformades ràpides de Fourier.

\subsection{Funcionament bàsic}
\label{subsec:funcionament-bàsic}

Els osci\lgem oscopis digitals es basen en l'ús d'un ADC (convertidor
analògic-digital), un sistema que converteix senyals analògics en
senyals digitals, les quals es processen per generar una representació
gràfica en temps real a la pantalla. L'eix horitzontal indica el
temps, i l'eix vertical indica generalment voltatge (tot i que es
poden mesurar altres magnituds com el corrent).

Tots els osci\lgem oscopis incorporen un subsistema de ``trigger''
\cite{funcionament-trigger} que té com a funció establir un punt de
referència i sincronitzar la captura de les dades. Aquest subsistema
és essencial per garantir una visualització estable i repetible. Sense
el ``trigger'', el senyal a visualitzar es desplaçaria constantment a
través de l'eix horitzontal, fent impossible la seva observació.

\subsection{Conceptes importants de senyals digitals}
\label{subsec:conceptes-pds}

Com que el treball se centra en osci\lgem oscopis digitals, és
necessari conèixer alguns dels conceptes claus del processament
digital del senyal \cite{llibre-pds}:

\begin{itemize}
	\item Senyal analògic (o continu): Tipus de senyal format per
          variables contínues. Encara que aquests valors estiguin
          confinats en un rang màxim i mínim, poden tenir una precisió
          infinita, no hi ha espais buits.
	\item Senyal digital (o discret): Seqüència de valors discrets
          separats en el temps. A diferència dels analògics, els
          senyals discrets tenen espais buits.
	\item Quantització: És el procés d'aproximar un valor continu
          al valor discret més proper. Sigui aproximació o truncament,
          sol introduir error de mesura, ja que un valor discret no
          pot representar els infinits decimals d'un valor continu.
	\item Resolució: És la diferència entre dos valors d'un rang
          discret. Determina el màxim error de discretització i el
          nombre de bits d'una mostra.
	\item Mostreig: Procés que transforma un senyal analògic en un
          senyal discret mitjançant l'ús repetit de la quantització.
          Cada valor quantitzat és una mostra del senyal analògic.
	\item Freqüència de mostreig: El nombre de mostres que captura
          un ADC cada segon. La màxima freqüència que podrà captar
          l'osci\lgem oscopi serà com a màxim la meitat de la
          freqüència de mostreig (criteri de Nyquist).
\end{itemize}

\chapter{OsPlot}

En aquest capítol primer s'explorarà la manera de convertir GNUPlot en
una eina per visualitzar dades en temps real. Seguidament, s'intentarà
dissenyar l'arquitectura més simple d'OsPlot, on una Arduino envia pel
port sèrie mostres d'un byte, i GNUPlot ho llegeix directament.
Després, s'analitzaran les dues vies possibles per desenvolupar un
osci\lgem oscopi amb sistema de ``trigger'' i s'intentarà ampliar les
arquitectures proposades. I finalment, es farà una comparació entre
arquitectures per evaluar les avantatges i inconvenients de cada una.

\section{Visualització en temps real amb GNUPlot}

Per tal de transformar GNUPlot en una eina que pugui simular un
osci\lgem oscopi, primer s'ha d'aconseguir una visualització en temps
real de les dades. Com s'ha mencionat a l'introducció, GNUPlot és una
eina per graficar que està dissenyada per llegir fitxers de dades
estàtics.

De fet, GNUPlot només pot generar un gràfic a partir d'un conjunt de
dades si s'arriba a la condició de final de fitxer (EOF). Tot i que el
port sèrie pot fer saltar la condició d'EOF (amb el caràcter EOT,
0x04), fer-ho reinicia l'Arduino cada cop que GNUPlot obre el port
sèrie. Per tant, es requereix algún programa auxiliar que mantingui
obert el flux de dades amb el microcontrolador i pugui generar de
manera fiable la condició d'EOF per a la lectura de dades.

En aquesta secció es detallarà la implementació d'aquest programa
auxiliar per establir una comunicació estable i permetre la
visualització en temps real de les dades en el gràfic de GNUPlot.

\subsection{Reescriptura contínua del fitxer}

En un primer moment, es pot pensar que la solució per aconseguir que
GNUPlot mostri dades en temps real seria reescriure contínuament un
fitxer de dades (preferiblement ubicat al directori /tmp per aprofitar
la velocitat de la memòria RAM). Però aquest enfocament presenta una
gran problemàtica.

Com que un programa auxiliar és el que estarà actualitzant el fitxer
de dades, caldrà alguna manera de sincronitzar les escriptures del
programa auxiliar i les lectures de GNUPlot. La principal dificultat
de sincronitzar aquest mètode ve perquè GNUPlot no ofereix una manera
directa per fer servir la comunicació entre processos. És difícil
establir una comunicació bidireccional entre productor i consumidor
(Programa auxiliar i GNUPlot) sense mètodes com les cues de missatges
\cite{cues-missatges} o ``sockets UNIX'' \cite{sockets-unix}.

Per altra banda, també preocupa la possible sobrecàrrega d'interactuar
amb un fitxer en constant reescriptura. Tot i que el fitxer està a la
memòria RAM, la interacció amb el fitxer requereix utilitzar crides de
sistema específiques per qualsevol operació (obertura/tancament,
escriptura, ``flush''...), podent afectar el rendiment de la solució
fins al punt d'impossibilitar-la.

\subsection{Canonades amb nom}

Una bona alternativa respecte a la reescriptura contínua serien les
canonades amb nom (\cite[``Named Pipes'']{canonades-nom}) o FIFOs
(``First-In First-Out''). Les canonades són un mecanisme de
comunicació unidireccional entre processos que permet la transmissió
de dades unidireccional. En concret, les canonades amb nom són
accessibles per qualsevol procés, ja que apareixen al sistema de
fitxers com un fitxer especial.

En contrast amb l'enfocament de reescriure contínuament un fitxer, les
canonades eviten la necessitat de sincronitzar les escriptures i
lectures entre el programa auxiliar i GNUPlot, ja que les dades es
transmeten directament de manera unidireccional. I tancar una canonada
per la banda del transmissor provoca un final de fitxer, generant la
condició perfecte per senyalitzar a GNUPlot que ha llegit totes les
mostres a representar.

A més, les canonades proporcionen un mecanisme de comunicació
eficient, ja que les dades es transmeten en memòria compartida, sense
la necessitat d'operacions de fitxers específiques. Això minimitza la
sobrecàrrega associada amb les crides de sistema per a l'obertura,
tancament i altres operacions de fitxers.

Però cal tenir en compte que l'ús de canonades pot generar
sobrecàrrega en la interacció amb el sistema de fitxers. Com que es
treballa amb la condició de final de fitxer, GNUPlot ha d'obrir i
tancar la canonada cada cop que arriba un bloc de mostres.

Això vol dir que, tot i que serà més eficient que la reescriptura d'un
fitxer (ja que és un mètode que està pensat per comunicar ràpidament
processos), les constants crides de sistema per a l'obertura i el
tancament de la canonada podrien afectar el rendiment d'aquesta
solució.

\section{L'arquitectura més simple d'OsPlot}

Després d'haver provat que es pot obtenir una visualització en temps
real de les dades a GNUPlot, es pot procedir a implementar una
arquitectura bàsica d'OsPlot.

Aquesta arquitectura utilitzarà un Arduino que contínuament generarà
mostres amb l'ADC per enviar-les a través del port sèrie. Com que
interessa tenir una freqüència de mostreig elevada (al voltant de 76
kHz), l'ADC produirà mostres amb una resolució útil de 8 bits a causa
de les limitacions pròpies del perifèric.

Es tindrà un programa auxiliar que obrirà una canonada amb nom i
mantindrà el port sèrie obert, reenviant les mostres cap a la canonada
i generant la condició d'EOF cada 500 mostres.

Finalment, l'intèrpret de GNUPlot executarà un script que configurarà
la visualització del gràfic i constantment llegirà les noves dades que
arribin a través de la canonada. La creació i destrucció d'aquest
procés estarà controlada pel programa auxiliar.

\subsection{Programa d'Arduino amb C}

Utilitzant el llenguatge C, s'ha desenvolupat un programa per a
l'Arduino que habilita l'ADC i el port sèrie per a la captura i
transmissió de mostres analògiques. S'ha triat aquest llenguatge
principalment perquè les llibreries del port sèrie (modificades de
l'assignatura de Programació de Baix nivell) estaven escrites en C.

En primer lloc, es configuren els paràmetres de l'ADC, indicant el pin
del qual llegir, A5, la tensió màxima de referència, 5 V, i el
``prescaler'' del rellotge a x128, donant una freqüència de mostreig
de 9615 Hz. Per aprofitar el temps, ja s'inicia la primera lectura de
l'ADC.

Seguidament, es configura el port sèrie per establir la velocitat de
transmissió a 1 Mbps, i altres configuracions típiques com 8 bits per
paquet, sense paritat i un bit de parada. Un cop inicialitzat
s'activen les interrupcions, ja que la llibreria del port sèrie ho
requereix.

Finalment, l'Arduino entra en un bucle infinit on espera que la mostra
estigui preparada. Quan ja s'obté la mostra, ràpidament s'inicia una
nova lectura i s'envia la mostra actual a l'ordinador.

\subsection{``Script'' de GNUPlot}

GNUPlot és un intèrpret d'ordres que permet generar gràfiques a partir
de dades. Per aconseguir la visualització en temps real de les dades
capturades, cal definir un seguit d'ordres que GNUPlot interpretarà
per fer la visualització de les dades.

Primer de tot s'han de configurar els aspectes visuals de la gràfica,
com ara els colors, els tipus de línies i els rangs dels eixos ``x'' i
``y''. Això es pot fer amb les ordres ``set style'' i ``set
xrange/yrange'' respectivament.

Llavors per aconseguir la primera visualització a partir de la
canonada, cal fer servir l'ordre ``plot''. Aquesta ordre és
responsable de generar el gràfic basat en les dades rebudes des de la
canonada. Per obtenir una representació adequada, és necessari
especificar-hi diversos paràmetres:

\begin{itemize}
	\item ``binary format="\%uchar"'': Aquest paràmetre té com a
          finalitat especificar el format de les dades que s'estan
          llegint des de la canonada. En aquest cas, s'indica que cada
          valor de l'eix ``x'' és un byte, i l'eix ``y'' el genera
          GNUPlot.
	\item ``using (column(0)/fs):(column(1)*5/255)'': Aquest
          paràmetre és responsable de l'adaptació dels valors dels
          eixos per aconseguir una representació adequada de les
          dades. L'expressió ``(column(0)/fs)'' fa referència a les
          dades de l'eix ``x'', que són dividides per la freqüència de
          mostreig per obtenir l'escala de temps. D'altra banda,
          l'expressió ``(column(1)*5/255)'' fa referència a les dades
          de l'eix ``y''. Mitjançant aquesta fórmula, les mostres es
          transformen a valors de tensió, ja que es multiplica per 5 V
          (rang màxim de l'ADC) i es divideix per 255 (rang màxim d'un
          byte).
\end{itemize}

Finalment, el ``script'' realitza el plot continu de les dades rebudes
entrant en un bucle que executa l'ordre ``replot''. Aquesta ordre
torna a executar l'ordre de ``plot'' anterior. Com els valors que
arriben a través de la canonada van canviant, l'ús de l'ordre
``replot'' és fonamental per aconseguir la visualització actualitzada
en temps real. En cada iteració del bucle, GNUPlot espera la recepció
de les noves dades i procedeix a regenerar el gràfic per reflectir els
últims canvis.

\newpage

\subsection{Programa auxiliar amb C}

L'últim pas és implementar la comunicació entre el port sèrie i
GNUPlot, la qual s'implementarà amb C. Aquesta elecció de llenguatge
es basa en la seva capacitat per gestionar canonades i interaccions
amb el port sèrie sense necessitat de llibreries addicionals.

Per començar, és necessari configurar el port sèrie. Amb l'objectiu
de simplificar el procés, s'utilitza l'eina \cite[``stty'']{stty}, que
permet configurar el fitxer del port sèrie com un pseudoterminal de
Linux. D'aquesta manera, és possible llegir-lo com un fitxer normal
mitjançant les funcions ``fopen'', ``fread'', i altres.

Després es crea el procés de GNUPlot utilitzant la comanda ``gnuplot
-e ``cua\_lectura='NOM\_FIFO'; fs=16000000/128/13'' plot.gnu'' on:
\begin{itemize}
      \item ``-e'': Accepta una llista d'ordres per l'intèrpret.
      \item ``cua\_lectura'': Aquesta ordre indica el nom de la
            canonada a GNUPlot.
      \item ``fs'': Aquesta ordre configura la freqüència de mostreig de
            les dades. Es calcula amb l'equació de la freqüència de l'ADC de
            l'Arduino.
      \item ``plot.gnu'': El nom del ``script'' de GNUPlot.
\end{itemize}

Un cop està tot inicialitzat, el programa entra en un bucle continu on
es llegeixen 500 bytes del port sèrie, s'obre la canonada i s'hi
escriuen els 500 bytes, i es tanca la canonada per generar la condició
de final de fitxer.

\subsection{Sistema de ``trigger''}

En aquesta versió simplificada d'OsPlot, s'ha prescindit de la
incorporació d'un sistema de ``trigger'', una funció imprescindible
per un osci\lgem oscopi. L'objectiu d'aquesta decisió era demostrar
que GNUPlot és una eina và\lgem ida per la visualització de dades en
temps real, alhora que s'estableixen unes bases de l'arquitectura
OsPlot. A partir d'aquí, existeixen dues variacions de l'arquitectura
que permeten incorporar un sistema de ``trigger''.

La primera opció és OsPlot-PC, en què el programa del microcontrolador
no requereix modificacions, mentre que el programa auxiliar,
mitjançant un algoritme determina quan es compleix la condició de
``trigger'' i envia un nombre de mostres a GNUPlot.

La segona opció és OsPlot-MCU, que implica modificar el programa del
microcontrolador per enviar un nombre determinat de mostres un cop es
produeixi la condició de ``trigger''. En aquest cas, l'algoritme
s'executaria directament en el microcontrolador, permetent un programa
auxiliar sense pràcticament modificacions.

\newpage

\section{OsPlot-PC}

\subsection{Descripció de l'arquitectura}

L'enfocament de l'arquitectura OsPlot-PC implica realitzar
modificacions en el programa auxiliar, mentre que el programa del
microcontrolador es manté intacte. El programa auxiliar es modifica
per incorporar un algoritme de ``trigger'' que contínuament analitza
les mostres rebudes i decideix el moment òptim per iniciar l'enviament
de dades a GNUPlot.

Un dels avantatges clau de l'opció OsPlot-PC (a part d'incorporar
``trigger'') és que permet realitzar un processament digital del
senyal complex amb totes les mostres que enviï el microcontrolador. Es
poden aplicar filtres digitals per eliminar soroll, fer operacions
matemàtiques complexes, o aplicar altres processaments específics per
extreure informació rellevant del senyal capturat.

A més, un altre avantatge significatiu és la possibilitat d'obtenir
velocitats de mostreig més elevades. En mantenir un programa petit al
microcontrolador, es manté la seva capacitat per generar mostres a
alta velocitat, mentre que el programa auxiliar s'encarrega de
gestionar el sistema del ``trigger''.

\subsection{Extensions}
\label{subsec:extensions-osplot-pc}

\subsubsection{Comunicació entre microcontrolador i ordinador}

Fins ara, s'ha posat èmfasi en la comunicació entre el
microcontrolador i l'ordinador utilitzant el port sèrie, ja que és el
perifèric més comú a la majoria d'ordinadors (el port USB). No obstant
això, no hi ha cap restricció que impedeixi l'ús d'altres busos
serial, com SPI o I2C, per transmetre les mostres des del
microcontrolador. Això es pot realitzar mitjançant adaptadors a USB, o
altres sistemes com ara una placa Raspberry Pi, que incorporen suport
per aquests busos de manera nativa.

A més, es pot ampliar encara més l'abast de comunicació utilitzant
altres microcontroladors com l'ESP32, que permeten la transmissió de
mostres utilitzant altres mètodes com ara Sockets TCP/IP o
WebSockets. Aquestes tecnologies permeten establir connexions de xarxa
entre el microcontrolador i l'ordinador, obrint noves possibilitats
com transmetre mostres a través de xarxes sense fils.

Si es decideix utilitzar la comunicació mitjançant ``sockets'',
principalment es pot enfocar de dues maneres:

\begin{itemize}
	\item Fent servir \cite[socat]{socat}, una eina que permet,
          entre altres funcionalitats, transformar un ``socket'' en un
          PTY. Això vol dir que un programa de ``trigger''
          desenvolupat per al port sèrie hauria de ser compatible amb
          qualsevol microcontrolador que faci servir ``sockets''.
	\item Treballar directament amb ``sockets''. Aquest mètode
          ofereix un millor rendiment, ja que no requereix cap mena de
          conversió addicional, però requereix reprogramar part del
          programa auxiliar.
\end{itemize}

\newpage

\subsubsection{Millores a GNUPlot i alternatives}

També és important destacar que l'enfocament actual s'ha centrat en la
comoditat i la simplicitat, utilitzant GNUPlot com un procés
independent del ``trigger''. Això ha facilitat el desenvolupament del
programa auxiliar i la seva integració amb el microcontrolador, però
si es vol obtenir una solució més elaborada i eficient s'hauria de
considerar l'ús de llibreries específiques per a GNUPlot, juntament
amb un ``framework'' d'interfície d'usuari que permeti crear una
interfície interactiva semblant a la d'un osci\lgem oscopi
tradicional.

L'ús de llibreries dedicades per a GNUPlot ofereix avantatges com un
major control i personalització dels gràfics, alhora que s'elimina la
necessitat de gestionar un segon procés. També permetria interactuar
directament amb GNUPlot, eliminant la necessitat d'una cua i les
crides al sistema implicades, millorant l'eficiència i el rendiment
del programa.

A més de les millores a GNUPlot, és rellevant assenyalar que hi ha
altres alternatives disponibles que poden ser més adequades en estar
preparades per integrar-se en un programa, a diferència de
GNUPlot. Una d'aquestes alternatives és
\href{https://docs.rs/plotters/latest/plotters}{\underline{plotters}},
una llibreria de ``Rust'' que permet crear gràfiques com les de
GNUPlot. Una altra alternativa és utilitzar
\href{https://www.chartjs.org/}{\underline{Chart.js}}, una llibreria
de ``JavaScript'' que, juntament amb ``frameworks'' com
\href{https://kit.svelte.dev/}{\underline{SvelteKit}}, permetria
desenvolupar una interfície gràfica universal. Les dues llibreries
mencionades suporten visualització en temps real de manera nativa.

\subsection{Diagrama de l'arquitectura}

\newpage

\section{OsPlot-MCU}

\subsection{Descripció de l'arquitectura}

OsPlot-MCU adopta un enfocament diferent per a la comunicació entre el
microcontrolador i l'ordinador. En aquest cas el programa del
microcontrolador es modifica per implementar el sistema de ``trigger''
directament en el mateix microcontrolador.

L'avantatge principal d'aquesta solució és la seva eficiència,
especialment quan el microcontrolador té una capacitat substancial de
processament disponible. D'aquesta manera s'aprofita la totalitat dels
recursos interns del microcontrolador per realitzar el processament
necessari, reduint la càrrega de computació a l'ordinador i alliberant
recursos per altres tasques.

Precisament per això, l'enfocament d'OsPlot-MCU és adequat en
situacions en què es desitja minimitzar la càrrega de computació a
l'ordinador per diversos motius. Per exemple, en aplicacions on s'ha
de considerar l'eficiència energètica o si es vol reduir la
dependència de l'ordinador per a tasques de processament intensives.

\subsection{Extensions}

Com amb OsPlot-PC, OsPlot-MCU ofereix altres opcions per la
comunicació entre el microcontrolador i l'ordinador. A part del port
sèrie, és possible utilitzar altres protocols de comunicació sèrie com
SPI o I2C, o fins i tot comunicació a través de ``sockets''. I també
existeix la possibilitat de fer servir llibreries específiques de
GNUPlot o altres eines per fer gràfiques com les que s'han mencionat a
l'apartat \ref{subsec:extensions-osplot-pc}.

\subsubsection{Comunicació bidireccional amb el microcontrolador}

En l'arquitectura OsPlot-MCU l'algoritme de ``trigger'' s'executa al
microcontrolador, pràcticament forçant a establir una comunicació
bidireccional per permetre l'ajust dels paràmetres del ``trigger''.
Això vol dir que pel port sèrie circularan bytes que no representen
mostres, obligant a establir algun mecanisme per distingir-los.

Una manera senzilla i eficient d'aconseguir-ho és utilitzant un
caràcter d'escapament i enviament per paquets. Per exemple, si prenem
el byte 128 com a caràcter d'escapament, una mostra amb valor 128 es
representaria com 128 i 128, mentre que un final del paquet de mostres
es pot indicar amb els bytes 128 i 0. Altres maneres més elaborades
impliquen l'ús d'eines com \href{Protobuf}{https://protobuf.dev/}, un
mecanisme eficient de serialització que permet estructurar dades per
crear un protocol de comunicació.

\subsection{Diagrama de l'arquitectura}

\printbibliography

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% LaTeX-biblatex-use-Biber: t
%%% End:
